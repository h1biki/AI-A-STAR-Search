"""

Using A* search, the heuristic value is generated by calculating the airline distance
and the heuristic value is within the actual cost and never overestimated(admissibility of A*).
Tie breaking, first found first, to prevent loop.
Tree search:
If the frontier is empty then return NO-PATH.
Choose a child to move and remove it from frontier.
If goal found then traceback to start and print the solution.
Expand the chosen one, add possible movements to frontiers.

"""

import os
import sys
import copy
import time

class Node:
    def __init__(self, mapsfromfile):
        self.id = None
        self.operator = None
        self.path = []
        self.grid = mapsfromfile
        self.rob_position = None  # [row, col]
        self.visited_list = []
        self.start = None
        self.goal = None
        self.g = 0
        self.h = 0
        self.f = 0
        self.parent = None
        self.children = []

    def __str__(self):
        return 'N' + str(self.id) + ':' + ' ' + '-'.join(self.path) + ' ' + str(self.g) + ' ' + str(self.h) + ' ' + str(self.f)

    # **heuristic value, by calculating airline distance, flooring**
    def retreve_heuristic(self):
        self.h = int((pow(abs(self.goal[0] - self.rob_position[0]), 2) + pow(abs(self.goal[1] - self.rob_position[1]), 2)) ** 0.5) # sqrt

    def retreve_f(self):
        self.f = self.g + self.h

    # searching for map contain S and G letter represent for start and goal
    def get_start_goal(self):
        for i in range(len(self.grid)):
            for j in range(len(self.grid)):
                if self.grid[i][j] == 'S':
                    self.start = [i, j]
                    self.rob_position = [i, j]  # robbie starts moving here
                    self.visited_list.append([i, j])
                if self.grid[i][j] == 'G':
                    self.goal = [i, j]  # final destination
        self.path.append('S')

    # check legal moves first, then move

    # DIAGONAL costs 1, NORMAL costs 2
    def movement_data(self, legal_movement):
        # NORMAL
        if legal_movement == 'L':
            self.rob_position = [self.rob_position[0], self.rob_position[1] - 1]
            self.operator = 'L'
            self.path.append(self.operator)
            self.g += 2
        # NORMAL
        elif legal_movement == 'R':
            self.rob_position = [self.rob_position[0], self.rob_position[1] + 1]
            self.operator = 'R'
            self.path.append(self.operator)
            self.g += 2
        # NORMAL
        elif legal_movement == 'U':
            self.rob_position = [self.rob_position[0] - 1, self.rob_position[1]]
            self.operator = 'U'
            self.path.append(self.operator)
            self.g += 2
        # NORMAL
        elif legal_movement == 'D':
            self.rob_position = [self.rob_position[0] + 1, self.rob_position[1]]
            self.operator = 'D'
            self.path.append(self.operator)
            self.g += 2
        # DIAGONAL
        elif legal_movement == 'UL':
            self.rob_position = [self.rob_position[0] - 1, self.rob_position[1] - 1]
            self.operator = 'UL'
            self.path.append(self.operator)
            self.g += 1

        # DIAGONAL
        elif legal_movement == 'UR':
            self.rob_position = [self.rob_position[0] - 1, self.rob_position[1] + 1]
            self.operator = 'UR'
            self.path.append(self.operator)
            self.g += 1

        # DIAGONAL
        elif legal_movement == 'DL':
            self.rob_position = [self.rob_position[0] + 1, self.rob_position[1] - 1]
            self.operator = 'DL'
            self.path.append(self.operator)
            self.g += 1

        # DIAGONAL
        elif legal_movement == 'DR':
            self.rob_position = [self.rob_position[0] + 1, self.rob_position[1] + 1]
            self.operator = 'DR'
            self.path.append(self.operator)
            self.g += 1


        # update visited nodes
        self.visited_list.append(self.rob_position)

    def find_legal_move(self):
        # this method will return a legal_movement list
        legal_movement = []

        # NORMAL
        # LEFT L
        if self.rob_position[1] - 1 >= 0:  # cannot breach the boundary
            if self.grid[self.rob_position[0]][self.rob_position[1] - 1] != 'X' and [self.rob_position[0], self.rob_position[1] - 1] not in self.visited_list:  # check X and whether visited
                legal_movement.append('L')
        # RIGHT R
        if self.rob_position[1] + 1 <= len(self.grid) - 1:  # position in list start from 0
            if self.grid[self.rob_position[0]][self.rob_position[1] + 1] != 'X' and [self.rob_position[0], self.rob_position[1] + 1] not in self.visited_list:
                legal_movement.append('R')
        # UP U
        if self.rob_position[0] - 1 >= 0:
            if self.grid[self.rob_position[0] - 1][self.rob_position[1]] != 'X' and [self.rob_position[0] - 1, self.rob_position[1]] not in self.visited_list:
                legal_movement.append('U')
        # DOWN D
        if self.rob_position[0] + 1 <= len(self.grid) - 1:
            if self.grid[self.rob_position[0] + 1][self.rob_position[1]] != 'X' and [self.rob_position[0] + 1, self.rob_position[1]] not in self.visited_list:
                legal_movement.append('D')

        # DIAGONAL # 3 dir's cannot be X
        # Up Left UL
        if self.rob_position[0] - 1 >= 0 and self.rob_position[1] - 1 >= 0:
            if self.grid[self.rob_position[0] - 1][self.rob_position[1] - 1] != 'X' and self.grid[self.rob_position[0]][self.rob_position[1] - 1] != 'X' and self.grid[self.rob_position[0] - 1][self.rob_position[1]] != 'X' and [self.rob_position[0] - 1, self.rob_position[1] - 1] not in self.visited_list:
                legal_movement.append('UL')

        # Down Right DR
        if self.rob_position[0] + 1 <= len(self.grid) - 1 and self.rob_position[1] + 1 <= len(self.grid) - 1:
            if self.grid[self.rob_position[0] + 1][self.rob_position[1] + 1] != 'X' and self.grid[self.rob_position[0]][self.rob_position[1] + 1] != 'X' and self.grid[self.rob_position[0] + 1][self.rob_position[1]] != 'X' and [self.rob_position[0] + 1, self.rob_position[1] + 1] not in self.visited_list:
                legal_movement.append('DR')

        # Up Right UR
        if self.rob_position[0] - 1 >= 0 and self.rob_position[1] + 1 <= len(self.grid) - 1:
            if self.grid[self.rob_position[0] - 1][self.rob_position[1] + 1] != 'X' and self.grid[self.rob_position[0]][self.rob_position[1] + 1] != 'X' and self.grid[self.rob_position[0] - 1][self.rob_position[1]] != 'X' and [self.rob_position[0] - 1, self.rob_position[1] + 1] not in self.visited_list:
                legal_movement.append('UR')

        # Down Left DL
        if self.rob_position[0] + 1 <= len(self.grid) - 1 and self.rob_position[1] - 1 >= 0:
            if self.grid[self.rob_position[0] + 1][self.rob_position[1] - 1] != 'X' and self.grid[self.rob_position[0]][self.rob_position[1] - 1] != 'X' and self.grid[self.rob_position[0] + 1][self.rob_position[1]] != 'X' and [self.rob_position[0] + 1, self.rob_position[1] - 1] not in self.visited_list:
                legal_movement.append('DL')

        return legal_movement

def a_star_search(frontier, fileO_abspath, closed, identifier, diag_times):
    # ready to write to file
    output_file = open(fileO_abspath, 'w')

    # 1st time it only contains the start node, after the first loop due to the super big value of best_f,
    # the best_f value will be replaced by the second one(to the start)'s f in the list and after that,
    # the normal comparison process begin
    while len(frontier) > 0:
        chosen = None
        best_f = float('+inf') # super big
        for i in range(len(frontier)):  # searching... when first loop, frontier only have the start node, len is 1

            if frontier[i].f < best_f: # f smaller the better
                best_f = frontier[i].f
                chosen = i
        parent = frontier.pop(chosen)  # bingo, and closed
        closed.append(parent)

        # check whether goal
        if parent.rob_position == parent.goal:
            result = []
            print("Writing File".center(50, '-'))

            # Fake progress bar start
            t = time.perf_counter()
            for i in range(51):
                a = '*' * i
                b = '.' * (50 - i)
                c = (i / 50) * 100
                t -= time.perf_counter()
                print("\t{:^3.0f}%[{}->{}]{:.2f}ms".format(c, a, b, -t)) # \t is for align
                time.sleep(0.02)
            # Fake progress bar end

            # traceback to start and draw route
            # deepcopy copy the item and open a new area of memory address, not direct reference, no influence on previous
            while parent.parent is not None: # back not the start point
                temp = copy.deepcopy(parent)
                temp.grid[temp.rob_position[0]][temp.rob_position[1]] = '*'  # current position indicator
                result.insert(0, temp)  # act like a stack
                parent = parent.parent

            temp = copy.deepcopy(parent) # back start point
            temp.grid[temp.rob_position[0]][temp.rob_position[1]] = '*'
            result.insert(0, temp)

            for res in result:

                print('-'.join(res.path), res.g, file = output_file)
                for i in res.grid:
                    print(' '.join(i), file = output_file)
                print('', file = output_file)
            return

        # searching in all legal movements
        possiblemove = parent.find_legal_move()
        for i in possiblemove:
            # simply copy the parent without changing
            child = copy.deepcopy(parent)
            # get possiblemoves certain values and send back up to compare f
            child.movement_data(i)
            child.retreve_heuristic()
            child.retreve_f()
            child.parent = parent
            # id self add
            identifier += 1
            child.id = identifier
            frontier.append(child)

        # print diag on screen
        if diag_times > 0:

            print('')
            print(parent)

            print('')
            print('CHILDREN: {(', end = '')
            for i in range(len(frontier)):
                if i == len(frontier) - 1:
                    print(frontier[len(frontier) - 1], end = ')}')
                else:
                    print(frontier[i], end = '), (')
            print('')

            print('FRONTIER: {(', end = '')
            for j in range(len(frontier)):
                if j == len(frontier) - 1:
                    print(frontier[len(frontier) - 1], end = ')}')
                else:
                    print(frontier[j], end = '), (')
            print('')

            print('CLOSED: {(', end = '')
            for k in range(len(closed)):
                if k == len(closed) - 1:
                    print(closed[len(closed) - 1], end = ')}')
                else:
                    print(closed[k], end = '), (')
            print('')

            print('*********************************************************************************')

            diag_times -= 1

    print('NO-PATH', file = output_file)
    output_file.close()

    return


# **************Main****************

# file IO part start

pyfiledir = os.path.dirname(__file__)
# path for input
relpath_i = sys.argv[1]
fileI_abspath = os.path.join(pyfiledir, relpath_i)
# path for output
relpath_o = sys.argv[2]
fileO_abspath = os.path.join(pyfiledir, relpath_o)

# open file
print("Loading Map From: " + fileI_abspath)
file = open(fileI_abspath, 'r')

# process the raw data to line
linedata = file.read().split()

# close file
file.close()
# file IO part over

# set times of the diagnostic output
diag_times = int(sys.argv[3])

# initialized map, by the scale number(1st line) of the file
initMap = []
for i in range(int(linedata[0])):
    initMap2nd = []
    for j in range(int(linedata[0])):
        initMap2nd.append(0)
    initMap.append(initMap2nd)

# then pop out the scale number
linedata.pop(0)

# loading map
for i in range(len(linedata)):
    for j in range(len(linedata)):
        initMap[i][j] = linedata[i][j]

print("Map Loaded, Start Searching... ".center(50, '-'))

# initialized node object
node = Node(initMap)
node.get_start_goal()

# search and print
frontier = [node]
identifier = 0
closed = []
frontier[0].id = identifier
a_star_search(frontier, fileO_abspath, closed, identifier, diag_times)
print("Searching Done, Best Solution Found!".center(50, '-'))
print("Solution Saved to: " + fileO_abspath)
